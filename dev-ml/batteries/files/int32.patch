commit 6153feee1ee88ce56ee87cc81e544673292918b2
Author: Gabriel Scherer <gabriel.scherer@gmail.com>
Date:   Tue Apr 19 08:41:15 2016 -0400

    safe-string: make Int32 safe

diff --git a/src/batInt32.mliv b/src/batInt32.mliv
index e1176c76..80c50af7 100644
--- a/src/batInt32.mliv
+++ b/src/batInt32.mliv
@@ -217,20 +217,20 @@ external float_of_bits : int32 -> float = "caml_int32_float_of_bits"
 val of_byte : char -> int32
 val to_byte : int32 -> char
 
-val pack : string -> int -> int32 -> unit
-(** [pack str off i] writes the little endian bit representation
-    of [i] into string [str] at offset [off] *)
+val pack : Bytes.t -> int -> int32 -> unit
+(** [pack s off i] writes the little endian bit representation
+    of [i] into byte sequence [s] at offset [off] *)
 
-val pack_big : string -> int -> int32 -> unit
-(** [pack_big str off i] writes the big endian bit
-    representation of [i] into string [str] at offset [off] *)
+val pack_big : Bytes.t -> int -> int32 -> unit
+(** [pack_big s off i] writes the big endian bit
+    representation of [i] into byte sequence [s] at offset [off] *)
 
-val unpack : string -> int -> int32
-(** [unpack str off] reads 4 bytes from string [str] starting at
+val unpack : Bytes.t -> int -> int32
+(** [unpack s off] reads 4 bytes from byte sequence [str] starting at
     offset [off] as a little-endian int32 *)
 
-val unpack_big : string -> int -> int32
-(** [unpack str off] reads 4 bytes from string [str] starting at
+val unpack_big : Bytes.t -> int -> int32
+(** [unpack s off] reads 4 bytes from byte sequence [str] starting at
     offset [off] as a big-endian int32 *)
 
 val compare : t -> t -> int
diff --git a/src/batInt32.mlv b/src/batInt32.mlv
index e2b884be..71e490ca 100644
--- a/src/batInt32.mlv
+++ b/src/batInt32.mlv
@@ -37,7 +37,7 @@ let of_byte b = Char.code b |> Int32.of_int
 
 (* really need to just blit an int32 word into a string and vice versa *)
 let pack str pos item =
-  if String.length str < pos + 4 then invalid_arg "Int32.pack: pos too close to end of string";
+  if Bytes.length str < pos + 4 then invalid_arg "Int32.pack: pos too close to end of string";
   if pos < 0 then invalid_arg "Int32.pack: pos negative";
   Bytes.set str pos (to_byte item);
   let item = Int32.shift_right item 8 in
@@ -48,16 +48,18 @@ let pack str pos item =
   Bytes.set str (pos + 3) (to_byte item) (* optimize out last logand? *)
 
 (*$T pack
-  let str = "    " in pack str 0 0l; (str = "\000\000\000\000")
-  let str = "     " in pack str 0 0l; (str = "\000\000\000\000 ")
-  let str = "     " in pack str 1 0l; (str = " \000\000\000\000")
-  let str = "   " in try pack str 0 0l; false with Invalid_argument _ -> true
-  let str = "    " in try pack str 1 0l; false with Invalid_argument _ -> true
+  let str = Bytes.of_string "    " in pack str 0 0l; (Bytes.to_string str = "\000\000\000\000")
+  let str = Bytes.of_string "     " in pack str 0 0l; (Bytes.to_string str = "\000\000\000\000 ")
+  let str = Bytes.of_string "     " in pack str 1 0l; (Bytes.to_string str = " \000\000\000\000")
+  let str = Bytes.of_string "   " in try pack str 0 0l; false with Invalid_argument _ -> true
+  let str = Bytes.of_string "    " in try pack str 1 0l; false with Invalid_argument _ -> true
 *)
 
 let pack_big str pos item =
-  if String.length str < pos + 4 then invalid_arg "Int32.pack_big: pos too close to end of string";
-  if pos < 0 then invalid_arg "Int32.pack_big: pos negative";
+  if Bytes.length str < pos + 4 then
+    invalid_arg "Int32.pack_big: pos too close to end of string";
+  if pos < 0 then
+    invalid_arg "Int32.pack_big: pos negative";
   Bytes.set str (pos + 3) (to_byte item);
   let item = Int32.shift_right item 8 in
   Bytes.set str (pos + 2) (to_byte item);
@@ -67,51 +69,58 @@ let pack_big str pos item =
   Bytes.set str pos (to_byte item) (* optimize out last logand? *)
 
 (*$T pack_big
-  let str = "    " in pack_big str 0 0l; (str = "\000\000\000\000")
-  let str = "     " in pack_big str 0 0l; (str = "\000\000\000\000 ")
-  let str = "     " in pack_big str 1 0l; (str = " \000\000\000\000")
-  let str = "   " in try pack_big str 0 0l; false with Invalid_argument _ -> true
-  let str = "    " in try pack_big str 1 0l; false with Invalid_argument _ -> true
+  let str = Bytes.of_string "    " in pack_big str 0 0l; (Bytes.to_string str =  "\000\000\000\000")
+  let str = Bytes.of_string "     " in pack_big str 0 0l; (Bytes.to_string str = "\000\000\000\000 ")
+  let str = Bytes.of_string "     " in pack_big str 1 0l; (Bytes.to_string str =  " \000\000\000\000")
+  let str = Bytes.of_string "   " in try pack_big str 0 0l; false with Invalid_argument _ -> true
+  let str = Bytes.of_string "    " in try pack_big str 1 0l; false with Invalid_argument _ -> true
 *)
 
 let unpack str pos =
-  if String.length str < pos + 4 then invalid_arg "Int32.unpack: pos + 4 not within string";
+  if Bytes.length str < pos + 4
+  then invalid_arg "Int32.unpack: pos + 4 not within string";
   if pos < 0 then invalid_arg "Int32.unpack: pos negative";
   let shift n = Int32.shift_left n 8
   and add b n = Int32.add (of_byte b) n in
-  of_byte str.[pos+3] |> shift |> add str.[pos+2] |> shift
-  |> add str.[pos+1] |> shift |> add str.[pos]
+  of_byte (Bytes.unsafe_get str (pos+3)) |> shift
+  |> add (Bytes.unsafe_get str (pos+2)) |> shift
+  |> add (Bytes.unsafe_get str (pos+1)) |> shift
+  |> add (Bytes.unsafe_get str pos)
 (* TODO: improve performance of bit twiddling?  will these curried functions get inlined? *)
 
 (*$T unpack
-  unpack "\000\000\000\000" 0 = 0l
-  unpack "\000\000\000\000 " 0 = 0l
-  unpack " \000\000\000\000" 1 = 0l
-  unpack "\255\000\000\000" 0 = 255l
+  unpack (Bytes.of_string "\000\000\000\000") 0 = 0l
+  unpack (Bytes.of_string "\000\000\000\000 ") 0 = 0l
+  unpack (Bytes.of_string " \000\000\000\000") 1 = 0l
+  unpack (Bytes.of_string "\255\000\000\000") 0 = 255l
 *)
 
 (*$Q pack; unpack
-  Q.int (let str = "    " in fun x -> let x = Int32.of_int x in pack str 0 x; unpack str 0 = x)
+  Q.int (let str = Bytes.of_string "    " in fun x -> let x = Int32.of_int x in pack str 0 x; unpack str 0 = x)
 *)
 
 
 let unpack_big str pos =
-  if String.length str < pos + 4 then invalid_arg "Int32.unpack: pos + 4 not within string";
-  if pos < 0 then invalid_arg "Int32.unpack: pos negative";
+  if Bytes.length str < pos + 4 then
+    invalid_arg "Int32.unpack: pos + 4 not within string";
+  if pos < 0 then
+    invalid_arg "Int32.unpack: pos negative";
   let shift n = Int32.shift_left n 8
   and add b n = Int32.add (of_byte b) n in
-  of_byte str.[pos] |> shift |> add str.[pos+1] |> shift
-  |> add str.[pos+2] |> shift |> add str.[pos+3]
+  of_byte (Bytes.unsafe_get str pos) |> shift
+  |> add (Bytes.unsafe_get str (pos+1)) |> shift
+  |> add (Bytes.unsafe_get str (pos+2)) |> shift
+  |> add (Bytes.unsafe_get str (pos+3))
 
 (*$T unpack_big
-  unpack_big "\000\000\000\000" 0 = 0l
-  unpack_big "\000\000\000\000 " 0 = 0l
-  unpack_big " \000\000\000\000 " 1 = 0l
-  unpack_big "\000\000\000\255" 0 = 255l
+  unpack_big (Bytes.of_string "\000\000\000\000") 0 = 0l
+  unpack_big (Bytes.of_string "\000\000\000\000 ") 0 = 0l
+  unpack_big (Bytes.of_string " \000\000\000\000 ") 1 = 0l
+  unpack_big (Bytes.of_string "\000\000\000\255") 0 = 255l
 *)
 
 (*$Q pack_big; unpack_big
-  Q.int (let str = "    " in fun x -> let x = Int32.of_int x in pack_big str 0 x; unpack_big str 0 = x)
+  Q.int (let str = Bytes.of_string "    " in fun x -> let x = Int32.of_int x in pack_big str 0 x; unpack_big str 0 = x)
 *)
 
 module BaseInt32 = struct
