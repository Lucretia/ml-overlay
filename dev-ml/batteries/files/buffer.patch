commit d12b5f15da0d880369185b3e62fd263f7d2285c9
Author: Gabriel Scherer <gabriel.scherer@gmail.com>
Date:   Sun Apr 17 22:54:27 2016 -0400

    safe-string: make IO safe

diff --git a/src/batBuffer.mlv b/src/batBuffer.mlv
index db25e6f9..b1064368 100644
--- a/src/batBuffer.mlv
+++ b/src/batBuffer.mlv
@@ -75,7 +75,7 @@ let add_input t inp n =
 let output_buffer buf =
   BatInnerIO.create_out
     ~write: (add_char buf)
-    ~output:(fun s p l -> add_substring buf s p l; l)
+    ~output:(fun s p l -> add_subbytes buf s p l; l)
     ~close: (fun () -> contents buf)
     ~flush: BatInnerIO.noop
 
diff --git a/src/batIO.ml b/src/batIO.ml
index 65f6916d..3fe7a715 100644
--- a/src/batIO.ml
+++ b/src/batIO.ml
@@ -133,7 +133,7 @@ let output_enum() =
       Buffer.add_char b x
     )
     ~output:(fun s p l ->
-      Buffer.add_substring b s p l;
+      Buffer.add_subbytes b s p l;
       l
     )
     ~close:(fun () ->
@@ -401,7 +401,7 @@ let from_in_channel ch =
   let read() =
     try
       if ch#input cbuf 0 1 = 0 then raise Sys_blocked_io;
-      String.unsafe_get cbuf 0
+      Bytes.unsafe_get cbuf 0
     with
       End_of_file -> raise No_more_input
   in
@@ -449,7 +449,7 @@ let from_in_chars ch =
 let from_out_chars ch =
   let output s p l =
     for i = p to p + l - 1 do
-      ch#put (String.unsafe_get s i)
+      ch#put (Bytes.unsafe_get s i)
     done;
     l
   in
@@ -498,20 +498,25 @@ let lines_of2 ic =
   let find_eol () =
     let rec find_loop pos =
       if pos >= !end_pos then !read_pos - pos
-      else if buf.[pos] = '\n' then 1 + pos - !read_pos (* TODO: HANDLE CRLF *)
+      else if Bytes.get buf pos = '\n'
+      then 1 + pos - !read_pos (* TODO: HANDLE CRLF *)
       else find_loop (pos+1)
     in
     find_loop !read_pos
   in
-  let rec join_strings buf pos = function
-    | [] -> buf
+  let join_strings total_len accu =
+    let rec loop buf pos = function
+    | [] -> ()
     | h::t ->
-      let len = String.length h in
-      String.blit h 0 buf (pos-len) len;
-      join_strings buf (pos-len) t
+      let len = Bytes.length h in
+      Bytes.blit h 0 buf (pos-len) len;
+      loop buf (pos-len) t in
+    let buf = Bytes.create total_len in
+    loop buf total_len accu;
+    Bytes.unsafe_to_string buf
   in
   let input_buf s o l =
-    String.blit buf !read_pos s o l;
+    Bytes.blit buf !read_pos s o l;
     read_pos := !read_pos + l;
     if !end_pos = !read_pos then
       try
@@ -529,15 +534,15 @@ let lines_of2 ic =
       let n = find_eol () in
       if n = 0 then match accu with  (* EOF *)
         | [] -> close_in ic; raise BatEnum.No_more_elements
-        | _ -> join_strings (Bytes.create len) len accu
+        | _ -> join_strings len accu
       else if n > 0 then (* newline found *)
         let res = Bytes.create (n-1) in
         input_buf res 0 (n-1);
-        input_buf " " 0 1; (* throw away EOL *)
+        input_buf (Bytes.of_string " ") 0 1; (* throw away EOL *)
         match accu with
-        | [] -> res
+        | [] -> Bytes.unsafe_to_string res
         | _ -> let len = len + n-1 in
-          join_strings (Bytes.create len) len (res :: accu)
+          join_strings len (res :: accu)
       else (* n < 0 ; no newline found *)
         let piece = Bytes.create (-n) in
         input_buf piece 0 (-n);
@@ -564,17 +569,18 @@ let tab_out ?(tab=' ') n out =
       write out c;
       if is_newline c then nwrite out spaces;
     )
-    ~output:(fun s p l -> (*Replace each newline within the segment with newline^spaces*) (*FIXME?: performance - instead output each line and a newline between each char? *)
-      let length = String.length s                 in
-      let buffer = Buffer.create (String.length s) in
+    ~output:(fun s p l ->
+      (*Replace each newline within the segment with newline^spaces*)
+      let length = Bytes.length s in
+      let buffer = Buffer.create length in
       for i = p to min (length - 1) l do
-        let c = String.unsafe_get s i in
+        let c = Bytes.unsafe_get s i in
         Buffer.add_char buffer c;
         if is_newline c then
           Buffer.add_string buffer spaces
       done;
-      let s' = Buffer.contents buffer                  in
-      output out s' 0 (String.length s'))
+      let s' = Buffer.to_bytes buffer in
+      really_output out s' 0 (Bytes.length s'))
     ~flush:noop
     ~close:noop
     ~underlying:[out]
diff --git a/src/batIO.mli b/src/batIO.mli
index f7d870da..affb11ea 100644
--- a/src/batIO.mli
+++ b/src/batIO.mli
@@ -189,13 +189,13 @@ val really_nread : input -> int -> string
     Example: [let read_md5 ch = really_nread ch 32]
 *)
 
-val input : input -> string -> int -> int -> int
-(** [input i s p l] reads up to [l] characters from the given input,
-    storing them in string [s], starting at character number [p]. It
+val input : input -> Bytes.t -> int -> int -> int
+(** [input i s p len] reads up to [len] characters from the given input,
+    storing them in byte sequence [s], starting at character number [p]. It
     returns the actual number of characters read (which may be 0) or
     raise [No_more_input] if no character can be read. It will raise
-    [Invalid_argument] if [p] and [l] do not designate a valid
-    substring of [s].
+    [Invalid_argument] if [p] and [len] do not designate a valid
+    subsequence of [s].
 
     Example: [let map_ch f ?(block_size=100) =
     let b = String.create block_size in
@@ -205,16 +205,15 @@ val input : input -> string -> int -> int -> int
     done with No_more_input -> ()]
 *)
 
-val really_input : input -> string -> int -> int -> int
-(** [really_input i s p l] reads exactly [l] characters from the
-    given input, storing them in the string [s], starting at
+val really_input : input -> Bytes.t -> int -> int -> int
+(** [really_input ic s p len] reads exactly [len] characters from the
+    input [ic], storing them in the string [s], starting at
     position [p]. For consistency with {!BatIO.input} it returns
-    [l]. @raise No_more_input if at [l] characters are not
-    available. @raise Invalid_argument if [p] and [l] do not
+    [len]. @raise No_more_input if at [len] characters are not
+    available. @raise Invalid_argument if [p] and [len] do not
     designate a valid substring of [s].
 
     Example: [let _ = really_input stdin b 0 3]
-
 *)
 
 val close_in : input -> unit
@@ -235,27 +234,37 @@ val nwrite : (string, _) printer
     Example: [nwrite stdout "Enter your name: ";]
 *)
 
-val output : 'a output -> string -> int -> int -> int
-(** [output o s p l] writes up to [l] characters from string [s], starting at
-    offset [p]. It returns the number of characters written. It will raise
-    [Invalid_argument] if [p] and [l] do not designate a valid substring of [s].
+val output : 'a output -> Bytes.t -> int -> int -> int
+(** [output o s p len] writes up to [len] characters from byte
+    sequence [s], starting at offset [p]. It returns the number of
+    characters written. It will raise [Invalid_argument] if [p] and
+    [len] do not designate a valid subsequence of [s].
 
-    Example: [let str = "Foo Bar Baz" in let written = output stdout str 2 4;]
+    Example: [let written = output stdout (Bytes.to_string "Foo Bar Baz") 2 4]
 
-    This writes "o Ba" to stdout.
-*)
+    This writes "o Ba" to stdout, and returns 4.
+ *)
 
-val really_output : 'a output -> string -> int -> int -> int
-(** [really_output o s p l] writes exactly [l] characters from string [s] onto
-    the the output, starting with the character at offset [p]. For consistency with
-    {!BatIO.output} it returns [l]. @raise Invalid_argument if [p] and [l] do not
-    designate a valid substring of [s].
+val output_substring : 'a output -> string -> int -> int -> int
+(** like [output] above, but outputs from a substring instead of
+    a subsequence of bytes *)
+
+val really_output : 'a output -> Bytes.t -> int -> int -> int
+(** [really_output o s p len] writes exactly [len] characters from
+    byte sequence [s] onto the the output, starting with the character
+    at offset [p]. For consistency with {!BatIO.output} it returns
+    [len]. @raise Invalid_argument if [p] and [len] do not designate
+    a valid subsequence of [s].
 
     This function is useful for networking situations where the output
     buffer might fill resulting in not the entire substring being
     readied for transmission.  Uses [output] internally, and will
     raise [Sys_blocked_io] in the case that any call returns 0.
-*)
+ *)
+
+val really_output_substring : 'a output -> string -> int -> int -> int
+(** like [really_output] above, but outputs from a substring instead
+    of a subsequence of bytes *)
 
 val flush : 'a output -> unit
 (** Flush an output.
@@ -593,7 +602,7 @@ val drop_bits : in_bits -> unit
 
 val create_in :
   read:(unit -> char) ->
-  input:(string -> int -> int -> int) ->
+  input:(Bytes.t -> int -> int -> int) ->
   close:(unit -> unit) -> input
 (** Fully create an input by giving all the needed functions.
 
@@ -604,7 +613,7 @@ val create_in :
 
 val wrap_in :
   read:(unit -> char) ->
-  input:(string -> int -> int -> int) ->
+  input:(Bytes.t -> int -> int -> int) ->
   close:(unit -> unit) ->
   underlying:(input list) ->
   input
@@ -622,7 +631,7 @@ val wrap_in :
 
 val inherit_in:
   ?read:(unit -> char) ->
-  ?input:(string -> int -> int -> int) ->
+  ?input:(Bytes.t -> int -> int -> int) ->
   ?close:(unit -> unit) ->
   input -> input
 (** Simplified and optimized version of {!wrap_in} which may be used
@@ -638,7 +647,7 @@ val inherit_in:
 
 val create_out :
   write:(char -> unit) ->
-  output:(string -> int -> int -> int) ->
+  output:(Bytes.t -> int -> int -> int) ->
   flush:(unit -> unit) ->
   close:(unit -> 'a) ->
   'a output
@@ -657,7 +666,7 @@ val create_out :
 
 val wrap_out :
   write:(char -> unit)         ->
-  output:(string -> int -> int -> int) ->
+  output:(Bytes.t -> int -> int -> int) ->
   flush:(unit -> unit)         ->
   close:(unit -> 'a)           ->
   underlying:('b output list)  ->
@@ -708,7 +717,7 @@ val wrap_out :
 
 val inherit_out:
   ?write:(char -> unit) ->
-  ?output:(string -> int -> int -> int) ->
+  ?output:(Bytes.t -> int -> int -> int) ->
   ?flush:(unit -> unit) ->
   ?close:(unit -> unit) ->
   'a output -> unit output
@@ -774,13 +783,13 @@ val to_input_channel : input -> in_channel
 
 class in_channel : input ->
   object
-    method input : string -> int -> int -> int
+    method input : Bytes.t -> int -> int -> int
     method close_in : unit -> unit
   end
 
 class out_channel : 'a output ->
   object
-    method output : string -> int -> int -> int
+    method output : Bytes.t -> int -> int -> int
     method flush : unit -> unit
     method close_out : unit -> unit
   end
diff --git a/src/batInnerIO.ml b/src/batInnerIO.ml
index 328482c6..4360ef1d 100644
--- a/src/batInnerIO.ml
+++ b/src/batInnerIO.ml
@@ -28,7 +28,7 @@ let weak_iter f s        = BatInnerWeaktbl.iter (fun x _ -> f x) s
 
 type input = {
   mutable in_read  : unit -> char;
-  mutable in_input : string -> int -> int -> int;
+  mutable in_input : Bytes.t -> int -> int -> int;
   mutable in_close : unit -> unit;
   in_id: int;(**A unique identifier.*)
   in_upstream: input weak_set
@@ -36,7 +36,7 @@ type input = {
 
 type 'a output = {
   mutable out_write : char -> unit;
-  mutable out_output: string -> int -> int -> int;
+  mutable out_output: Bytes.t -> int -> int -> int;
   mutable out_close : unit -> 'a;
   mutable out_flush : unit -> unit;
   out_id:    int;(**A unique identifier.*)
@@ -217,14 +217,14 @@ let nread i n =
         p := !p + r;
         l := !l - r;
       done;
-      s
+      Bytes.unsafe_to_string s
     with
       No_more_input as e ->
       if !p = 0 then raise e;
-      String.sub s 0 !p
+      Bytes.sub_string s 0 !p
 
 let really_output o s p l' =
-  let sl = String.length s in
+  let sl = Bytes.length s in
   if p + l' > sl || p < 0 || l' < 0 then invalid_arg "BatIO.really_output";
   let l = ref l' in
   let p = ref p in
@@ -236,8 +236,11 @@ let really_output o s p l' =
   done;
   l'
 
+let really_output_substring o s p l' =
+  really_output o (Bytes.of_string s) p l'
+
 let input i s p l =
-  let sl = String.length s in
+  let sl = Bytes.length s in
   if p + l > sl || p < 0 || l < 0 then invalid_arg "BatIO.input";
   if l = 0 then
     0
@@ -245,7 +248,7 @@ let input i s p l =
     i.in_input s p l
 
 let really_input i s p l' =
-  let sl = String.length s in
+  let sl = Bytes.length s in
   if p + l' > sl || p < 0 || l' < 0 then invalid_arg "BatIO.really_input";
   let l = ref l' in
   let p = ref p in
@@ -264,14 +267,13 @@ let really_nread i n =
     let s = Bytes.create n
     in
     ignore(really_input i s 0 n);
-    s
-
+    Bytes.unsafe_to_string s
 
 let write o x = o.out_write x
 
-let nwrite o s =
+let nwrite_bytes o s =
   let p = ref 0 in
-  let l = ref (String.length s) in
+  let l = ref (Bytes.length s) in
   while !l > 0 do
     let w = o.out_output s !p !l in
     (* FIXME: unknown how many characters were already written *)
@@ -280,11 +282,16 @@ let nwrite o s =
     l := !l - w;
   done
 
+let nwrite o s = nwrite_bytes o (Bytes.unsafe_of_string s)
+
 let output o s p l =
-  let sl = String.length s in
+  let sl = Bytes.length s in
   if p + l > sl || p < 0 || l < 0 then invalid_arg "BatIO.output";
   o.out_output s p l
 
+let output_substring o s p l =
+  output o (Bytes.unsafe_of_string s) p l
+
 let flush o = o.out_flush()
 
 let flush_all () =
@@ -313,9 +320,9 @@ let read_all i =
   | Input_closed ->
     let buf = Bytes.create !pos in
     List.iter (fun (s,p) ->
-      String.unsafe_blit s 0 buf p (String.length s)
+      Bytes.blit_string s 0 buf p (String.length s)
     ) !str;
-    buf
+    Bytes.unsafe_to_string buf
 
 let input_string s =
   let pos = ref 0 in
@@ -327,7 +334,7 @@ let input_string s =
     ~input:(fun sout p l ->
       if !pos >= len then raise No_more_input;
       let n = (if !pos + l > len then len - !pos else l) in
-      String.unsafe_blit s (post pos ( (+) n ) ) sout p n;
+      Bytes.blit_string s (post pos ( (+) n ) ) sout p n;
       n
     )
     ~close:noop
@@ -349,7 +356,7 @@ let output_string() =
   let b = Buffer.create default_buffer_size in
   create_out
     ~write:  (fun c -> Buffer.add_char b c )
-    ~output: (fun s p l -> Buffer.add_substring b s p l;  l  )
+    ~output: (fun s p l -> Buffer.add_subbytes b s p l;  l  )
     ~close:  (fun () -> Buffer.contents b)
     ~flush:  noop
 
@@ -416,8 +423,11 @@ let pipe() =
   in
   let input s p l =
     if !inpos = String.length !input then flush();
-    let r = (if !inpos + l > String.length !input then String.length !input - !inpos else l) in
-    String.unsafe_blit !input !inpos s p r;
+    let r =
+      if !inpos + l <= String.length !input
+      then l
+      else String.length !input - !inpos in
+    Bytes.blit_string !input !inpos s p r;
     inpos := !inpos + r;
     r
   in
@@ -425,7 +435,7 @@ let pipe() =
     Buffer.add_char output c
   in
   let output s p l =
-    Buffer.add_substring output s p l;
+    Buffer.add_subbytes output s p l;
     l
   in
   let input  = create_in ~read ~input  ~close:noop
@@ -571,6 +581,9 @@ let write_string o s =
   nwrite o s;
   write o '\000'
 
+let write_bytes o b =
+  nwrite o b
+
 let write_line o s =
   nwrite o s;
   write o '\n'
diff --git a/src/batInnerIO.mli b/src/batInnerIO.mli
index 9130f853..16510b03 100644
--- a/src/batInnerIO.mli
+++ b/src/batInnerIO.mli
@@ -70,19 +70,21 @@ val really_nread : input -> int -> string
     from the input. @raise No_more_input if at least [n] characters are
     not available. @raise Invalid_argument if [n] < 0. *)
 
-val input : input -> string -> int -> int -> int
-(** [input i s p l] reads up to [l] characters from the given input, storing
-    them in string [s], starting at character number [p]. It returns the actual
-    number of characters read or raise [No_more_input] if no character can be
-    read. It will raise [Invalid_argument] if [p] and [l] do not designate a
-    valid substring of [s]. *)
-
-val really_input : input -> string -> int -> int -> int
-(** [really_input i s p l] reads exactly [l] characters from the given input,
-    storing them in the string [s], starting at position [p]. For consistency with
-    {!BatIO.input} it returns [l]. @raise No_more_input if at [l] characters are
-    not available. @raise Invalid_argument if [p] and [l] do not designate a
-    valid substring of [s]. *)
+val input : input -> Bytes.t -> int -> int -> int
+(** [input i s p len] reads up to [len] bytes from the given input,
+    storing them in byte sequence [s], starting at position [p]. It
+    returns the actual number of bytes read or raise
+    [No_more_input] if no character can be read. It will raise
+    [Invalid_argument] if [p] and [len] do not designate a valid
+    subsequence of [s]. *)
+
+val really_input : input -> Bytes.t -> int -> int -> int
+(** [really_input i s p len] reads exactly [len] characters from the
+    given input, storing them in the byte sequence [s], starting at
+    position [p]. For consistency with {!BatIO.input} it returns
+    [len]. @raise No_more_input if at least [len] characters are not
+    available. @raise Invalid_argument if [p] and [len] do not designate
+    a valid subsequence of [s]. *)
 
 val close_in : input -> unit
 (** Close the input. It can no longer be read from. *)
@@ -97,16 +99,29 @@ val write : 'a output -> char -> unit
 val nwrite : 'a output -> string -> unit
 (** Write a string to an output. *)
 
-val output : 'a output -> string -> int -> int -> int
-(** [output o s p l] writes up to [l] characters from string [s], starting at
-    offset [p]. It returns the number of characters written. It will raise
-    [Invalid_argument] if [p] and [l] do not designate a valid substring of [s]. *)
+val nwrite_bytes : 'a output -> Bytes.t -> unit
+(** Write a byte sequence to an output. *)
 
-val really_output : 'a output -> string -> int -> int -> int
-(** [really_output o s p l] writes exactly [l] characters from string [s] onto
-    the the output, starting with the character at offset [p]. For consistency with
-    {!BatIO.output} it returns [l]. @raise Invalid_argument if [p] and [l] do not
-    designate a valid substring of [s]. *)
+val output : 'a output -> Bytes.t -> int -> int -> int
+(** [output o s p len] writes up to [len] characters from byte
+    sequence [len], starting at offset [p]. It returns the number of
+    characters written. It will raise [Invalid_argument] if [p] and
+    [len] do not designate a valid subsequence of [s]. *)
+
+val output_substring : 'a output -> string -> int -> int -> int
+(** like [output] above, but outputs from a substring instead of
+    a subsequence of bytes *)
+
+val really_output : 'a output -> Bytes.t -> int -> int -> int
+(** [really_output o s p len] writes exactly [len] characters from
+    byte sequence [s] onto the the output, starting with the character
+    at offset [p]. For consistency with {!BatIO.output} it returns
+    [len]. @raise Invalid_argument if [p] and [len] do not designate
+    a valid subsequence of [s]. *)
+
+val really_output_substring : 'a output -> string -> int -> int -> int
+(** like [really_output] above, but outputs from a substring instead
+    of a subsequence of bytes *)
 
 val flush : 'a output -> unit
 (** Flush an output. *)
@@ -136,7 +151,7 @@ val on_close_out : 'a output -> ('a output -> unit) -> unit
 
 val create_in :
   read:(unit -> char) ->
-  input:(string -> int -> int -> int) ->
+  input:(Bytes.t -> int -> int -> int) ->
   close:(unit -> unit) -> input
 (** Fully create an input by giving all the needed functions.
 
@@ -147,7 +162,7 @@ val create_in :
 
 val inherit_in:
   ?read:(unit -> char) ->
-  ?input:(string -> int -> int -> int) ->
+  ?input:(Bytes.t -> int -> int -> int) ->
   ?close:(unit -> unit) ->
   input -> input
 (**
@@ -158,7 +173,7 @@ val inherit_in:
 
 val wrap_in :
   read:(unit -> char) ->
-  input:(string -> int -> int -> int) ->
+  input:(Bytes.t -> int -> int -> int) ->
   close:(unit -> unit) ->
   underlying:(input list) ->
   input
@@ -173,7 +188,7 @@ val wrap_in :
 
 val create_out :
   write:(char -> unit) ->
-  output:(string -> int -> int -> int) ->
+  output:(Bytes.t -> int -> int -> int) ->
   flush:(unit -> unit) ->
   close:(unit -> 'a) ->
   'a output
@@ -192,7 +207,7 @@ val create_out :
 
 val inherit_out:
   ?write:(char -> unit) ->
-  ?output:(string -> int -> int -> int) ->
+  ?output:(Bytes.t -> int -> int -> int) ->
   ?flush:(unit -> unit) ->
   ?close:(unit -> unit) ->
   _ output -> unit output
@@ -204,7 +219,7 @@ val inherit_out:
 
 val wrap_out :
   write:(char -> unit)         ->
-  output:(string -> int -> int -> int) ->
+  output:(Bytes.t -> int -> int -> int) ->
   flush:(unit -> unit)         ->
   close:(unit -> 'a)           ->
   underlying:('b output list)  ->
@@ -437,7 +452,7 @@ external noop        : unit      -> unit        = "%ignore"
    {7 Optimized access to fields}
 *)
 
-val get_output : _ output -> (string -> int -> int -> int)
+val get_output : _ output -> (Bytes.t -> int -> int -> int)
 val get_flush  : _ output -> (unit -> unit)
 
 val lock : BatConcurrent.lock ref
